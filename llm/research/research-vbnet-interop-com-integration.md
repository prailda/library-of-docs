Отлично. Я подготовлю подробное, пошаговое и практическое руководство по созданию COM-библиотеки на VB.NET для Excel Desktop (последняя версия, 64-бит), с возможностью регистрации вручную через консоль без установщика. Руководство будет вести пользователя от нуля до готовой COM-библиотеки, доступной в VBE через References. Оно будет включать примеры создания собственных классов, функций, объектов и интеграции с объектной моделью Excel.

Я сообщу вам, когда оно будет готово.


# Ультимативное руководство по созданию COM-надстроек для Excel на VB.NET

## Введение

**Цель:** Научить вас шаг за шагом создавать собственные COM-надстройки для Excel (настольная версия Office) с помощью VB.NET. После изучения этого руководства вы сможете **создать библиотеку классов .NET**, которую затем зарегистрируете как COM-компонент и подключите через "Ссылки" (References) в редакторе VBA (VBE) Excel. После подключения ваша библиотека будет доступна VBA-коду так, **будто это встроенная библиотека Office** – со всеми своими классами, методами, свойствами и т.д.

**Почему COM-надстройка?** COM (Component Object Model) – это технология, позволяющая приложениям взаимодействовать через *объекты*. Excel и другие приложения Office поддерживают COM-компоненты, поэтому мы создадим .NET-библиотеку, видимую как COM. В результате Excel сможет вызывать код, написанный на VB.NET, а вы – расширять возможности VBA. Мы сфокусируемся на практических шагах, *минимум теории* – всё объясняется просто и прикладно, как если бы мы делали проект вместе.

**Современные версии:** Мы будем использовать новейшие доступные версии инструментов на 2025 год. В примере – Excel из Microsoft 365 (настольный Excel версии 2016+), Visual Studio 2022 и .NET Framework 4.8. (.NET 5+ или .NET Core тут не подходят без дополнительной настройки, данная методика рассчитана на .NET Framework вплоть до версии 4.8.) Все шаги учитывают **64-битную версию** Office, поскольку современные Office обычно 64-бит. Мы также укажем, как поддержать 32-бит при необходимости.

В итоге мы вместе разработаем рабочую COM-библиотеку (надстройку), зарегистрируем её и подключим в Excel. Вы своими руками повторите весь путь – **от создания проекта до использования ваших классов в VBA**, используя наши примеры (классы, функции, объекты, взаимодействие с объектной моделью Excel).

## Шаг 1: Создание проекта VB.NET Class Library (классической .NET)

Начнём с создания проекта библиотеки классов VB.NET в Visual Studio:

1. **Запустите Visual Studio 2022 от имени администратора.** Это нужно, чтобы Visual Studio могла сразу зарегистрировать ваш COM-компонент в реестре при сборке (упрощает тестирование). Если забыть, позже всегда можно зарегистрировать вручную, но на время разработки запуск от администратора удобен.

2. **Создайте новый проект типа "Class Library" на .NET Framework.** В диалоговом окне создания проекта выберите шаблон **Class Library (.NET Framework)** для Visual Basic. Убедитесь, что выбрана именно полнофункциональная .NET Framework (например, версия 4.8), а не ".NET Standard" или ".NET Core" – последние не поддерживают прямую COM-регистрацию без дополнительных настроек. Дайте проекту понятное имя, например: `ExcelComAddInDemo`.

   *Примечание:* В Visual Studio 2022 галочка "Make assembly COM-Visible" может отсутствовать на главной вкладке свойств, поэтому мы настроим видимость для COM вручную в следующих шагах.

3. **Настройте платформу сборки под вашу версию Office.** Если у вас Excel 64-бит, проект должен компилироваться под x64; если Excel 32-бит – под x86. Откройте свойства проекта (Project → Properties) и на вкладке **Compile (Сборка)** найдите опцию **Platform**. Создайте нужные конфигурации: для 64-бит выберите x64, для 32-бит – x86. Опция "Any CPU" **не подходит** для COM-надстроек Office – для поддержки обеих разрядностей нужно создавать и регистрировать две сборки (x86 и x64) отдельно. В нашем руководстве будем ориентироваться на 64-бит Excel (x64).

4. **Укажите подписывание сборки (опционально).** Можно пропустить этот шаг для тестового примера. Однако если планируете распространять надстройку, имеет смысл подписать сборку строгим именем (Strong Name) и/или поместить в GAC. В простом же случае регистрации с `/codebase` (о ней далее) подписывать необязательно.

Ваш проект создан. Теперь настроим его для COM.

## Шаг 2: Включение поддержки COM Interop в проекте

Чтобы .NET-библиотека могла выступать как COM-объект, нужно сделать несколько настроек:

* **COM-видимость сборки.** По умолчанию .NET-классы невидимы для COM. Нужно явно разрешить экспорт в COM. В VB.NET это можно сделать двумя путями:

  * **Через AssemblyInfo:** Откройте файл `My Project/AssemblyInfo.vb` и убедитесь, что там есть строка `[assembly: ComVisible(True)]`. Если её нет или стоит False, добавьте/измените на True. Эта настройка делает *все* публичные типы сборки видимыми COM (если не перегружено на уровне классов).
  * *Либо* поставьте галочку **"Make assembly COM-Visible"**. В VS2022 она находится в диалоге Assembly Information (кнопка "Assembly Information..." на вкладке Application в свойствах проекта). Установите эту галочку и сохраните.

* **Регистрация для COM Interop (на этапе сборки).** Visual Studio может автоматизировать регистрацию COM-компонента после сборки. В свойствах проекта на вкладке **Compile** (или Build) найдите параметр **"Register for COM interop"** и включите его. Помните, Visual Studio должна быть запущена с правами администратора, иначе ей не хватит прав записать в реестр. Если всё сделано, то при сборке VS выполнит `regasm` за вас.

* **GUID для библиотеки (TypeLib GUID).** Каждая COM-библиотека имеет идентификатор (GUID). Visual Studio сгенерирует его автоматически при первой регистрации. Вы можете увидеть его (и при желании задать свой) в AssemblyInfo.vb через атрибут `<Assembly: Guid("...")>`. Для нашего руководства менять его не требуется – автосгенерированного достаточно.

Итак, теперь проект готов экспортировать классы в COM. Далее перейдём к созданию самих классов и методов, которые будут доступны в Excel.

## Шаг 3: Реализация COM-видимых классов и функций

В этом шаге мы создадим несколько классов в VB.NET, которые хотим использовать из Excel. Покажем на примерах:

* **Класс с пользовательскими функциями** (пример: калькулятор для сложения чисел).
* **Класс-обёртка для Excel** (пример: методы, работающие с объектной моделью Excel).
* *(Опционально)* Пара слов о событиях и сложных объектах.

При создании COM-классов важно обеспечить их корректную экспозицию в COM: нужен уникальный GUID для класса, интерфейса и (при необходимости) для событий. В VB.NET существует удобный атрибут `<ComClass>`, который упрощает эту задачу, автоматически генерируя необходимую COM-инфраструктуру для класса. Мы воспользуемся им.

Перед началом **сгенерируйте GUIDы** для своих классов. В VS есть утилита **Create GUID** (Инструменты → Create GUID). Выберите формат "Registry Format" и сгенерируйте несколько GUID. Нам понадобится **3 GUID на каждый класс**: один для идентификатора класса (CLSID), один для интерфейса и один для событийного интерфейса (даже если событий нет, его можно сгенерировать пустым).

### Пример 1: Класс `Calculator` – простой калькулятор

Создадим класс с именем `Calculator`, который предоставляет простые функции. Добавьте в проект новый файл класса *Calculator.vb* (или переименуйте существующий `Class1.vb`). Вот код с комментариями:

```vbnet
Imports System.Runtime.InteropServices

<ComClass(Calculator.ClassId, Calculator.InterfaceId, Calculator.EventsId)> _
Public Class Calculator

    ' Эти три GUID необходимо заменить на ваши собственные! 
    ' Используйте утилиту Create GUID и вставьте значения (без фигурных скобок).
    Public Const ClassId As String = "XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX"
    Public Const InterfaceId As String = "YYYYYYYY-YYYY-YYYY-YYYY-YYYYYYYYYYYY"
    Public Const EventsId As String = "ZZZZZZZZ-ZZZZ-ZZZZ-ZZZZ-ZZZZZZZZZZZZ"

    ' Пустой конструктор (обязателен для COM)
    Public Sub New()
        ' Конструктор может быть пустым, нужен для создания объекта COM.
    End Sub

    ' Пример метода: сложение двух чисел
    Public Function Add(a As Double, b As Double) As Double
        Return a + b
    End Function

    ' Пример свойства: последнее вычисленное значение 
    Private lastResult As Double  ' приватное поле для хранения значения

    Public Property LastResult() As Double
        Get
            Return lastResult
        End Get
        Set(value As Double)
            lastResult = value
        End Set
    End Property

    ' Метод, использующий свойство: складывает и сохраняет результат
    Public Function AddAndStore(a As Double, b As Double) As Double
        Dim sum As Double = a + b
        lastResult = sum
        Return sum
    End Function

End Class
```

Объяснение важных моментов:

* Атрибут `<ComClass(...)>` указывает компилятору создать COM-класс. Мы передаем три GUID: для класса, интерфейса и событий. **Каждый класс должен иметь свои уникальные GUID**. Никогда не используйте GUID из примера – всегда генерируйте новые!.

* Публичный класс с ComClass автоматически **экспортируется в COM** (он также автоматически `ComVisible(True)`, так как мы разрешили это на уровне сборки). Visual Studio сгенерирует необходимый COM-интерфейс (IDispatch) для методов и свойств класса.

* Наличие **публичного конструктора без параметров** (`Public Sub New()` пустой) обязательно. Иначе Excel (через COM) не сможет создать объект вашего класса. Наш конструктор пуст, этого достаточно.

* Мы создали методы `Add` и `AddAndStore` и свойство `LastResult` как примеры функций и свойств. Они *Public* – значит будут доступны из VBA. Приватное поле `lastResult` не видно из вне (и не экспортируется).

* `Add` – простая функция (берёт два числа, возвращает сумму). `AddAndStore` – чуть сложнее: сохраняет результат во внутреннем поле и возвращает. Это демонстрирует, что ваш объект может иметь внутреннее состояние (как `LastResult`) и VBA-код может читать/записывать свойства объекта.

* *События:* В этом классе мы для простоты не реализуем события, но мы всё равно указали GUID для Events (EventsId). Если бы класс генерировал события, VB.NET/COM создал бы для них отдельный интерфейс. В нашем случае событий нет, но GUID должен быть уникальным (можно сгенерировать и не использовать). О работе с событиями см. ниже.

После написания кода `Calculator` у вас есть **первый COM-класс**. Он предоставит VBA два метода и свойство.

### Пример 2: Класс `ExcelHelper` – взаимодействие с Excel

Теперь создадим второй класс – для примера того, как .NET код может управлять Excel через его объектную модель. Назовём его `ExcelHelper`. Он покажет, как из .NET-кода получить доступ к открытой книге Excel, диапазонам и т.д., используя Interop.

1. **Добавьте ссылку на библиотеку Excel в проект .NET.** В проекте откройте меню Project → Add Reference... → вкладка COM. Найдите **"Microsoft Excel 16.0 Object Library"** (или аналогичную для вашей версии Excel) и добавьте её. Это подключит межоптимую библиотеку (Microsoft.Office.Interop.Excel), позволяющую типобезопасно работать с объектами Excel. (Альтернативно, можно было бы использовать late binding через `Object`, но с явным Interop-типом на VB.NET писать удобнее.)

2. Теперь добавьте класс `ExcelHelper.vb` с кодом ниже:

```vbnet
Imports System.Runtime.InteropServices
Imports Microsoft.Office.Interop.Excel

<ComClass(ExcelHelper.ClassId, ExcelHelper.InterfaceId, ExcelHelper.EventsId)> _
Public Class ExcelHelper

    ' Замените следующие GUID на новые уникальные значения для этого класса
    Public Const ClassId As String = "AAAAAAAA-AAAA-AAAA-AAAA-AAAAAAAAAAAA"
    Public Const InterfaceId As String = "BBBBBBBB-BBBB-BBBB-BBBB-BBBBBBBBBBBB"
    Public Const EventsId As String = "CCCCCCCC-CCCC-CCCC-CCCC-CCCCCCCCCCCC"

    Public Sub New()
        ' Конструктор COM-класса ExcelHelper
    End Sub

    ' Пример 1: Метод суммирует все числа в указанном диапазоне Excel
    Public Function SumRange(app As Application, rangeAddress As String) As Double
        Try
            Dim rng As Range = app.Range(rangeAddress)
            ' Используем встроенную функцию Excel для суммы
            Dim result As Double = app.WorksheetFunction.Sum(rng)
            Return result
        Catch ex As Exception
            ' В случае ошибки (например, неправильный адрес) вернем 0
            Return 0
        End Try
    End Function

    ' Пример 2: Метод подсвечивает (выделяет цветом) указанный диапазон 
    Public Sub HighlightRange(app As Application, rangeAddress As String)
        Try
            Dim rng As Range = app.Range(rangeAddress)
            ' Зальем ячейки желтым цветом (ColorIndex 6 = Yellow)
            rng.Interior.ColorIndex = 6  ' желтая заливка
        Catch ex As Exception
            ' Игнорируем ошибки (например, неправильный адрес)
        End Try
    End Sub

    ' Пример 3: Метод возвращает список имен всех листов книги в виде массива строк
    Public Function GetSheetNames(app As Application) As Object
        Dim names As New List(Of String)
        For Each sh As Worksheet In app.ActiveWorkbook.Worksheets
            names.Add(sh.Name)
        Next
        ' Преобразуем List в массив, чтобы вернуть удобный для VBA SafeArray
        Return names.ToArray()  ' массив строк
    End Function

End Class
```

Здесь мы демонстрируем несколько способов взаимодействия с Excel:

* Методы `SumRange` и `HighlightRange` принимают параметр `app As Excel.Application` и строку адреса диапазона. **Важно:** Мы ожидаем, что VBA передаст в `app` объект `Excel.Application` – обычно это объект `Application` из VBA, который мы передадим при вызове. Мы решили явно требовать Excel.Application для наглядности; *альтернатива:* использовать `Marshal.GetActiveObject("Excel.Application")` внутри метода, чтобы получить запущенный Excel. Однако передача `Application` как аргумента надёжнее (особенно если несколько экземпляров Excel).

* `SumRange` использует `WorksheetFunction.Sum` для просуммирования значений диапазона (чтобы не писать цикл вручную). Он заключён в `Try/Catch` на случай неверного адреса или типа данных. Возвращается `Double`. В VBA это станет тип *Double*.

* `HighlightRange` меняет свойство `Interior.ColorIndex` диапазона, заполняя ячейки жёлтым цветом (индекс 6 – стандартный желтый). Опять же, обрабатываем исключения тихо, чтобы не вызывать ошибок VBA в случае проблем.

* `GetSheetNames` проходит по всем листам активной книги (`app.ActiveWorkbook.Worksheets`) и собирает их имена в список строк, а затем возвращает массив строк (`names.ToArray()`). Возврат массива типа `String()` из .NET будет восприниматься в VBA как **SafeArray** строк (типа Variant() или String()). Таким образом, VBA сможет получить этот результат и, например, перебрать имена листов. Возврат массивов – хороший пример того, как COM-маршаллер передает коллекции.

Обратите внимание, что мы использовали типы из `Microsoft.Office.Interop.Excel` (например, `Application`, `Range`, `Worksheet`). Благодаря добавленной COM-ссылке эти типы известны .NET. При компиляции Interop-типбиблиотека может встроиться в вашу сборку (Embed Interop Types, по умолчанию True в VS2010+), так что на клиентской машине не потребуется отдельная Primary Interop Assembly – достаточно установленного Excel.

Наш класс `ExcelHelper` также помечен `<ComClass>` с собственными GUID. У него есть публичный конструктор и три публичных метода. Эти методы будут видны в VBA.

**Совет:** Если у вас возникнет необходимость добавить ещё классы – делайте по аналогии. Каждый класс, который вы хотите использовать из VBA, должен быть `Public` и либо помечен `<ComClass>`, либо, как вариант, иметь атрибуты `<ComVisible(True)>` и явный интерфейс/GUID. В VB.NET использование ComClass заметно упрощает дело, поэтому мы выбрали его. Visual Studio фактически сама сгенерирует COM-интерфейсы (на основе ваших публичных методов/свойств) и зарегистрирует ProgID.

После создания классов `Calculator` и `ExcelHelper` давайте проверим, всё ли настроено правильно перед сборкой:

* AssemblyInfo содержит ComVisible(True).

* Каждый класс имеет ComClass с уникальными GUID.

* Методы и свойства, которые должны быть доступны, объявлены Public.

* **Параметры методов** используют поддерживаемые COM-типы. Например, в наших методах мы используем `Double`, `String`, объекты Excel (Application, Range) и массив строк на выходе. Все эти типы совместимы с COM: числовые типы и строки напрямую, объекты Excel – это COM-объекты, массив строк будет marshaled как SafeArray of BSTR. Нужно избегать типов, непонятных COM (например, `Integer` (Int32) нормально, а `Long` как Int64 не поддерживается VBA напрямую). В нашем коде всё совместимо.

* **ByVal/ByRef:** По умолчанию в VB.NET параметры идут ByVal (как у нас). COM может работать и с ByRef, но VBA лучше воспринимает ByVal. Если не требуется модифицировать аргумент, держите параметры ByVal. (В нашем примере все параметры ByVal.)

* **Возврат значений:** Если метод возвращает значение, тип должен быть совместим (как Double, String, Object/Variant и т.п.). Sub ничего не возвращает – тоже ок.

Теперь мы готовы собирать проект и регистрировать библиотеку.

## Шаг 4: Сборка и регистрация COM-библиотеки

Скомпилируем наш проект и зарегистрируем его как COM-компонент.

### Сборка DLL

В Visual Studio выберите **Build → Build Solution** (Сборка решения). Если вы включили "Register for COM interop" и запустили VS с правами администратора, то при сборке должны произойти два результата:

* Создастся файл нашей DLL, например `ExcelComAddInDemo.dll` (в папке `bin\Debug` или `bin\Release` – в зависимости от выбранной конфигурации).
* Visual Studio автоматически вызовет регистрацию COM (через regasm) для этой DLL. Если успех, ваша библиотека уже будет в реестре как COM-объект, готовый к использованию.

**Важно:** Если сборка прошла, но библиотека *не* появилась в списке ссылок Excel (как проверим в следующем шаге), возможно регистрация не произошла. Тогда придётся выполнить её вручную.

### Регистрация вручную (Regasm)

Если **Visual Studio не регистрирует DLL автоматически** (например, вы не запустили с админ-правами или не включили Register for COM Interop), используйте инструмент **Regasm.exe** (Assembly Registration Tool). Это консольная утилита .NET для регистрации сборок в COM.

**Никогда не используйте** `regsvr32` для .NET DLL – он предназначен для Win32/COM DLL (например, написанных на C++/VB6) и даст ошибку, т.к. .NET-библиотеки не содержат `DllRegisterServer`. Вместо этого применяем `regasm`.

Порядок действий:

1. Откройте консоль *Developer Command Prompt for VS 2022* (или любую командную строку) **от имени администратора**.

2. Перейдите в папку с вашей скомпилированной DLL (например, `cd C:\YourPath\ExcelComAddInDemo\bin\Debug`).

3. Выполните команду регистрации. Для 64-битной Office нужно использовать 64-битную версию Regasm, для 32-битной – 32-битную. В Windows имеется две версии regasm:

   * 64-бит находится обычно по пути: `C:\Windows\Microsoft.NET\Framework64\v4.0.30319\RegAsm.exe`
   * 32-бит: `C:\Windows\Microsoft.NET\Framework\v4.0.30319\RegAsm.exe`

   Пример команды для 64-бит регистрации:

   ```shell
   C:\Windows\Microsoft.NET\Framework64\v4.0.30319\RegAsm.exe ExcelComAddInDemo.dll /codebase /tlb:ExcelComAddInDemo.tlb
   ```

   Здесь:

   * `/codebase` – указывает regasm добавить в реестр путь к сборке (иначе COM-клиент не узнает, где искать DLL, если она не в GAC). Этот ключ важен, если вы не подписывали DLL и не помещали её в GAC.
   * `/tlb:ExcelComAddInDemo.tlb` – опционально, создаст и зарегистрирует типовую библиотеку (Type Library) .tlb. Это может помочь Excel’у увидеть ваши типы. Хотя regasm и без явного .tlb генерирует записи в реестре, наличие .tlb полезно для явного подключения через "Browse..." в диалоге ссылок. Мы указали имя tlb-файла (он сохранится рядом с dll).

   После выполнения команды вы должны увидеть сообщение об успешной регистрации типов и создании библиотеки типов.

4. Если нужен 32-битный вариант (для 32-бит Excel или для поддержки обоих):

   * Сначала перекомпилируйте проект с конфигурацией x86 (как мы настраивали).
   * Затем запустите **32-битный** regasm (из `Framework` папки, не Framework64) на 32-битную сборку:

     ```shell
     C:\Windows\Microsoft.NET\Framework\v4.0.30319\RegAsm.exe ExcelComAddInDemo.dll /codebase /tlb:ExcelComAddInDemo32.tlb
     ```
   * Таким образом, у вас в реестре будут зарегистрированы обе версии (с разными GUID класс объектов, но они одинаковые, так как GUIDы мы прописали вручную – т.е. и 32 и 64 регистрация ссылаются на один ProgID и GUID классов, но разный бинарник). Excel 64-bit возьмет 64-битную DLL, Excel 32-bit – 32-битную.

5. **Перегистрация при изменениях:** Если вы пересобрали DLL с изменениями (например, добавили методы), обычно достаточно снова выполнить regasm (старые записи обновятся). Однако, при серьезных изменениях интерфейсов COM иногда лучше сначала удалить старую регистрацию: `regasm /unregister ExcelComAddInDemo.dll`, затем снова зарегистрировать. Также если меняли GUID, старая версия останется в реестре – не забудьте убрать, чтобы не было конфликтов.

6. **Регистрация для текущего пользователя:** По умолчанию regasm пишет в HKLM (для всех пользователей), требуя админа. Если у вас нет прав админа, можно выполнить трюк: `regasm /regfile:out.reg Your.dll`, затем вручную отредактировать out.reg, заменив все `HKEY_CLASSES_ROOT` на `HKEY_CURRENT_USER\Software\Classes`, и импортировать reg-файл. Это зарегистрирует COM-компонент под текущим пользователем без привилегий. В нашем руководстве предполагается возможность запустить с админ-правами, поэтому мы регистрируем обычно.

Теперь, когда DLL зарегистрирована, она становится видна системе как COM-сервер. **Как проверить регистрацию?** Откройте редактор реестра regedit и убедитесь, что в ветках `HKCR\CLSID\{GUID вашего класса}` и `HKCR\ExcelComAddInDemo.Calculator` (ProgID обычно "Namespace.Classname") появились соответствующие записи. Но можно и проще – сразу перейдём в Excel и попробуем подключить библиотеку.

## Шаг 5: Подключение библиотеки в Excel и использование классов

Настал момент истины – проверить, работает ли наша надстройка в Excel.

1. **Откройте Excel** (используем настольный Excel, последней версии). **Включите вкладку "Разработчик"** (Developer), если она ещё не активна: Файл → Параметры → Настроить ленту → поставьте галочку "Разработчик".

2. **Откройте редактор VBA (VBE).** На вкладке Разработчик нажмите "Visual Basic" (или нажмите `Alt+F11`). Откроется VBE.

3. **Подключите нашу библиотеку через References (Ссылки).** В VBE выберите меню **Tools (Сервис) → References (Ссылки)...**. Появится окно "Available References" – список доступных библиотек. Здесь должен быть пункт с именем нашей библиотеки. Искомое имя обычно совпадает с именем проекта/сборки. В нашем случае ищите, например, **ExcelComAddInDemo** (или другое, если вы назвали проект иначе). Если вы указали GUID библиотеки, также может отображаться название типа библиотеки. Отметьте флажок рядом с нашей библиотекой и нажмите OK.

   * *Если вы **не нашли** свою библиотеку в списке*: попробуйте нажать кнопку "Browse..." и перейти к файлу `ExcelComAddInDemo.tlb` (если вы его генерировали) или к самой DLL. Это принудительно добавит ее. Также убедитесь, что регистрировали с флагом `/codebase` – без него Excel не знает путь к DLL.
   * Если библиотека всё равно не отображается или не подключается – вернитесь к шагу 4 и проверьте регистрацию. Часто проблема – отсутствие необходимого интерфейса/GUID. Например, если вы забыли ComClass/GUID, библиотека могла не экспортировать классов в TypeLib. Согласно лучшим практикам, для появления в списке нужен *публичный класс с публичным интерфейсом, у обоих прописаны GUID*. Наш подход с ComClass это обеспечивает.

4. **Используем надстройку в VBA-коде.** Теперь наша библиотека подключена, и VBA "знает" о наших классах и методах. Попробуем написать макросы, использующие их. В окне проекта VBA (Project Explorer) выберите, например, объект *ThisWorkbook* или модуль *Module1* (если нет модуля, можно добавить: Insert → Module). Напишите такую тестовую процедуру:

```vba
Sub TestCalculator()
    Dim calc As New ExcelComAddInDemo.Calculator  ' Создаем объект нашего класса
    Dim result As Double
    
    result = calc.Add(2, 3)
    MsgBox "2 + 3 = " & result   ' должно показать "2 + 3 = 5"
    
    result = calc.AddAndStore(10, 5)
    MsgBox "10 + 5 = " & result & "; LastResult = " & calc.LastResult
    ' Окно покажет "10 + 5 = 15; LastResult = 15"
End Sub
```

Запустите этот макрос (поставьте курсор внутрь процедуры и нажмите F5). Вы должны получить два диалоговых окна с результатами сложения. Если это работает – значит класс `Calculator` успешно создаётся и его методы функционируют в VBA. Обратите внимание, как мы используем его практически так же, как встроенные объекты VBA. Свойство `LastResult` доступно, и IntelliSense в редакторе VBA *должна* его показывать при наборе кода (например, после `calc.` должны выпасть методы Add, AddAndStore, свойство LastResult и стандартные члены COM-объекта).

> **Интеллисенс:** Если подсказки методов/свойств не появляются, это может быть связано с тем, как .NET экспонировал интерфейс. По умолчанию .NET может предоставить только IDispatch (позднее связывание), тогда IntelliSense не знает о членах. Решение – атрибуты ClassInterface или явные интерфейсы. Наш способ с ComClass, как правило, генерирует Dual-интерфейс, поэтому IntelliSense должна работать. В противном случае можно явно указать `<ClassInterface(ClassInterfaceType.AutoDual)>` над классом или реализовать интерфейс вручную. Подробно: *«...по умолчанию библиотека создаётся только с интерфейсом позднего связывания, поэтому редактор кода не знает типов во время дизайна»*. Использование AutoDual или отдельных интерфейсов устраняет проблему.

Далее протестируем второй класс:

```vba
Sub TestExcelHelper()
    Dim helper As New ExcelComAddInDemo.ExcelHelper
    
    ' Предполагается, что на текущем листе Excel в ячейках A1:A5 есть какие-то числа
    Dim sum As Double
    sum = helper.SumRange(Application, "A1:A5")
    MsgBox "Сумма диапазона A1:A5 = " & sum
    
    ' Подсветим эти ячейки желтым
    helper.HighlightRange Application, "A1:A5"
    
    ' Получим список имен листов текущей книги
    Dim sheets As Variant
    sheets = helper.GetSheetNames(Application)
    Dim msg As String
    Dim i As Integer
    For i = LBound(sheets) To UBound(sheets)
        msg = msg & sheets(i) & vbCrLf
    Next
    MsgBox "Листы в книге:" & vbCrLf & msg
End Sub
```

Пройдёмся по этому макросу:

* Мы создаем объект `ExcelHelper`.
* Вызываем `SumRange`, передавая `Application` (это стандартный объект Excel VBA, представляющий текущее приложение Excel) и строку "A1\:A5". Метод вернул сумму, которую мы показываем через MsgBox. Можно поменять значения в этих ячейках и снова запустить макрос, убедиться, что сумма считается правильно .NET-ом.
* Затем вызываем `HighlightRange` для того же диапазона – после выполнения ячейки A1\:A5 закрасятся жёлтым.
* Далее получаем `sheets` как Variant (SafeArray строк) из `GetSheetNames`. Мы проходим от LBound до UBound массива и собираем имена листов в строку, выводим их. Это подтверждает, что массив успешно передан из .NET в VBA.

Если все сообщения и действия соответствуют ожиданиям – **поздравляем, ваша COM-надстройка работает!** 🎉 Теперь вы можете использовать возможности VB.NET внутри VBA: вычисления, вызов .NET API, более сложные алгоритмы, использование .NET-библиотек, и всё это интегрируя с Excel.

## Дополнительные советы и заключение

Мы прошли полный путь: от создания проекта до работающего примера. Далее – несколько советов и возможностей для развития:

* **Упаковка и распространение:** В реальных сценариях, после разработки вы можете захотеть поделиться надстройкой. Проще всего – раздать DLL и .tlb вместе со скриптом регистрации (например, файл `.bat` с командами regasm). Более продвинутый вариант – создать установщик (MSI) или использовать regasm /regfile и Powershell для регистрации при установке. Но в рамках нашей задачи достаточно знать команду regasm, которая учитывает нужные параметры регистрации в контексте текущего пользователя/системы (мы использовали `/codebase` и нужную разрядность).

* **Удаление (Unregister):** Чтобы удалить компоненты, используйте `regasm /unregister Your.dll` (в той же разрядности, что регистрировали). Это уберёт записи из реестра. Если вы распространяете обновления, лучше перед новой версией вызывать unreg старой (особенно если GUID классов менялись).

* **Совместимость:** Наш пример рассчитан на **последние версии Excel 2016+ / Office 365** (Object Library 16.0). Для других приложений Office (Word, Outlook и т.д.) процедура аналогична – разница лишь в библиотеках объектов. Вы можете подключать библиотеку Word Object Library и создавать аналогичные классы для Word (например, для автоматизации документов) – VBA Word также сможет через References использовать ваши классы. Этот подход универсален для всех Office-приложений, поддерживающих COM-надстройки.

* **Использование без IDE:** Мы описывали действия в Visual Studio, но все шаги можно выполнить вручную при желании. VB.NET-код можно скомпилировать через командную строку (vbc.exe), а регистрация – regasm. Так что, понимая процесс, вы *теоретически* могли бы написать код на листке, вбить его в Блокнот, скомпилировать и зарегистрировать – и получить тот же результат. Конечно, IDE ускоряет разработку, но важно, что **никакой магии, всё под вашим контролем**.

* **COM-интерфейсы и расширение функциональности:** Мы выбрали путь с `<ComClass>` для простоты. Продвинутые разработчики могут вручную определять интерфейсы (например, `Interface ICalculator` с DispId для каждого метода) и реализовывать их в классах, контролируя таким образом точное содержимое COM-интерфейса. Это полезно для версии библиотеки: добавляя методы, лучше не менять существующий интерфейс, а реализовать новый – чтобы старый код не сломался. Также можно реализовывать **события**: для этого в VB.NET достаточно объявить `Public Event EventName(...)` в классе с ComClass – Visual Studio сама сгенерирует необходимый событийный интерфейс (GUID EventsId мы для этого и указывали). В VBA можно затем использовать WithEvents и обрабатывать эти события. Например, вы могли бы добавить в `Calculator` событие `CalculationDone(result as Double)` и вызывать его в конце метода AddAndStore – тогда Excel-VBA мог бы поймать момент вычисления через обработчик события. Эти детали выходят за рамки нашего введения, но знайте, что COM-надстройки могут поддерживать и события, и сложные объекты, и коллекции.

* **Отладка:** Отлаживать такую библиотеку можно, прикрепляясь дебаггером VS к процессу Excel. Запустите Excel, в VS воспользуйтесь Debug → Attach to Process → excel.exe, и поставьте точки останова в своем коде. Когда VBA вызовет метод, вы попадёте в отладчик .NET. Это значительно облегчает поиск ошибок.

* **Производительность:** Вызовы из VBA в .NET через COM имеют накладные расходы (маршаллинг данных). Для крупномасштабных вычислений .NET обычно быстрее VBA, но частое переключение контекста может замедлять. По возможности, старайтесь писать методы, которые делают значительную работу за один вызов, чем вызывать множество маленьких методов в цикле из VBA.

И наконец, **результат:** вы получили полноценную COM-библиотеку, которая появляется в VBA как стандартная библиотека. Мы убедились, что:

* 64-бит Excel распознаёт нашу 64-бит DLL (в 32-бит сценарии потребовалась бы отдельная регистрация).
* VBA-код успешно создает объекты наших классов через `New` и вызывает методы.
* Классы взаимодействуют с Excel (читают/пишут в книги и листы).
* Это можно расширять: добавлять свои функции, использовать .NET для работы с файлами, веб-запросами, базами данных и предоставлять эти возможности VBA.

**Помните:** хотя мы делали пример для Excel, всё аналогично работает с Word, PowerPoint, Outlook и т.д. Вы можете создавать COM-расширения для любого Office-продукта. Достаточно добавить ссылку на соответствующую Object Library (например, Word) и написать классы, используя объекты Word (например, открыть документ, заменить текст, форматировать — и вызывать из Word VBA).

Мы прошли путь от *нулевого уровня знаний* до создания рабочей надстройки. Дальше – дело практики. Экспериментируйте, добавьте в наш пример новые методы, попробуйте обратиться к другим возможностям Excel (диаграммы, диапазоны, формулы). Благодаря COM-взаимодействию ваш VB.NET код может практически всё, что умеет VBA, и даже больше – используя богатство .NET Framework.

Успехов в разработке! Теперь у вас есть мощный инструмент для расширения Office-приложений. Ваши пользователи или коллеги смогут просто поставить галочку в "Ссылках" на вашу библиотеку и пользоваться её функционалом так же, как встроенным VBA. Это и есть критерий успеха, которого мы добились.

Happy coding! 🚀

**Источники и ссылки:**

* Microsoft Docs – *Regasm.exe (Assembly Registration Tool)* (о правильной регистрации .NET-компонентов, использование 32/64-bit Regasm).
* Stack Overflow – *Making .NET Class Library COM-Visible in VS2022* (рекомендации по выбору .NET Framework, настройке COM-Visible, разрядности).
* Rich Newman’s Blog – *Calling a .NET Library from Excel* (шаги создания библиотеки, подключение в Excel).
* Аналитика Docs – *Writing your own COM component in VB.NET* (пример использования атрибута ComClass и GUID в VB.NET).
* CodeProject – *Exposing .NET Classes to COM* (альтернативный подход с явными интерфейсами, для интересующихся глубиной).
